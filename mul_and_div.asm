			;---Main----------------------------------------------------------------------------------------------
			mov		r0, #3		;r0 = 3
			mov		r1, #2		;r1 = 4
			add		r2, r1, r0	;r2 = r1 + r0
			ldr		r3, =511		;r3 = 511 (100%)
			;mov		r3, #511		;ОШИБКА!
			ldr		r3,=512
			;ldr		r7, VALUE		;ОШИБКА!
			
			ldr		r2,=4		;счётчик цикла
			;loop
			;		subs		r2, r2, #0x1	;декремент счётчика (влияет на флаги)
			;		bne		loop			;если "нулевой" флаг не установлен, то loop
			
			
			ldr		r5, =36
			ldr		r6, =-4
			;bl		fast_mul
			bl		div
			
			end		;конец работы программы
			;-----------------------------------------------------------------------------------------------------
			
			
			;функция	умножения двух целых чисел
			;r5		- множимое, r6 - множитель, r7 - результат
fast_mul
			ldr		r7, =0			;r7 = 0
			;---проверка	на нули---
			cmp		r5, #0
			moveq	pc, lr			;выход, если множимое = 0
			cmp		r6, #0
			moveq	pc, lr			;выход, если множитель = 0
			;--сам	алгоритм умножения----
			mov		r8, r5			;r8 = копия множимого
			mov		r9, r6			;r9 = копия множителя
mul_loop
			ands		r10, r9, #1		;r10 = r9 & 0...01 (флаги устанавливаются)
			addne	r7, r7, r8		;r7 = r7 + r8, если не установлен Z
			lsl		r8, r8, #1		;логический сдвиг влево
			lsrs		r9, r9, #1		;логический сдвиг вправо (флаги устанавливаются)
			bne		mul_loop			;если r9 <> 0, то переход к mul_loop
			mov		pc, lr
			
			
			
			;функция	деления двух целых чисел
			;r5		- делимое, r6 - делитель, r7 - результат
div
			;---проверка	на нули---
			cmp		r5, #0
			moveq	pc, lr			;выход, если делимое = 0
			cmp		r6, #0
			moveq	pc, lr			;выход, если делитель = 0
			;---сам	алгоритм деления---
			ldr		r10, =0
			mov		r8, r5			;копия делимого (в будущем модуль этого числа)
			cmp		r8, #0
			submi	r8, r10, r8
			mov		r11, r8			;вторая копия делимого (его модуль)
			mov		r9, r6			;копия делителя
			cmp		r9, #0
			submi	r9, r10, r9
			mov		r0, r9			;r0 = копия делителя (модуль)
			ldr		r10, =1			;r10 = 1
div_loop
			lsrs		r8, r8, #1		;логический сдвиг вправо (флаги устанавливаются)
			addne	r10, r10, #1		;r10 = r10 + 1	(разрядность делимого)
			bne		div_loop			;если r8 <> 0, то переход к div_loop
			ldr		r12, =2			;r12 = 2
div_loop_two
			cmp		r11, #0
			lsl		r9, r0, r10		;r9 = r0 << r10
			addmi	r11, r11, r9		;r11 = r11 + r6 << r10 (флаг N = 1)
			subpl	r11, r11, r9		;r11 = r11 - r6 << r10 (флаг N = 0)
			subS		r10, r10, #1
			bmi		els
			cmp		r11, #0
			addpl	r7, r7, r12, lsl r10	;r7 = r7 + 2^(r10)
			b		next
			;---случай	для 2^0---
els
			cmp		r11, #0
			addpl	r7, r7, #1
next
			cmp		r10, #0
			bpl		div_loop_two
			;---проверка	знака---
			ldr		r10, =0
			cmp		r5, #0
			submi	r7, r10, r7		;смена знака
			cmp		r6, #0
			submi	r7, r10, r7		;смена знака
			
			mov		pc, lr
			
			
			
			
			
