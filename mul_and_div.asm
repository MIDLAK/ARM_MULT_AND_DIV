			;---Main----------------------------------------------------------------------------------------------
			ldr		r5, =-1000
			ldr		r6, =4
			;bl		mul
			bl		div
			
			end		;конец работы программы
			;-----------------------------------------------------------------------------------------------------
			
			
			;функция	умножения двух целых чисел
			;r5		- множимое, r6 - множитель, r7 - результат
mul
			ldr		r7, =0			;r7 = 0
			;---проверка	на нули---
			cmp		r5, #0
			moveq	pc, lr			;выход, если множимое = 0
			cmp		r6, #0
			moveq	pc, lr			;выход, если множитель = 0
			;--сам	алгоритм умножения----
			mov		r8, r5			;r8 = копия множимого
			mov		r9, r6			;r9 = копия множителя
mul_loop
			ands		r10, r9, #1		;r10 = r9 & 0...01 (флаги устанавливаются)
			addne	r7, r7, r8		;r7 = r7 + r8, если не установлен Z
			lsl		r8, r8, #1		;логический сдвиг влево
			lsrs		r9, r9, #1		;логический сдвиг вправо (флаги устанавливаются)
			bne		mul_loop			;если r9 <> 0, то переход к mul_loop
			mov		pc, lr			;конец подпрограммы
			
			
			
			;функция	деления двух целых чисел
			;r5		- делимое, r6 - делитель, r7 - результат
div
			;---проверка	на нули---
			cmp		r5, #0
			moveq	pc, lr			;выход, если делимое = 0
			cmp		r6, #0
			moveq	pc, lr			;выход, если делитель = 0
			;---сам	алгоритм деления---
			ldr		r10, =0			;r10 = 0
			mov		r8, r5			;r8 = копия делимого
			cmp		r8, #0
			submi	r8, r10, r8		;смена знака (флаг N = 1)
			mov		r11, r8			;r11 = вторая копия делимого
			mov		r9, r6			;r9 = копия делителя
			cmp		r9, #0
			submi	r9, r10, r9		;смена знака (флаг N = 1)
			mov		r0, r9			;r0 = копия делителя
			ldr		r10, =1			;r10 = 1
div_loop
			lsrs		r8, r8, #1		;логический сдвиг вправо (флаги устанавливаются)
			addne	r10, r10, #1		;r10 = r10 + 1	(разрядность делимого)
			bne		div_loop			;если r8 <> 0, то переход к div_loop
			ldr		r12, =1			;r12 = 1 (нужна для 2^n)
div_loop_two
			cmp		r11, #0
			lsl		r9, r0, r10		;r9 = r0 << r10
			addmi	r11, r11, r9		;r11 = r11 + r6 << r10 (флаг N = 1)
			subpl	r11, r11, r9		;r11 = r11 - r6 << r10 (флаг N = 0)
			cmp		r11, #0
			addpl	r7, r7, r12, lsl r10	;r7 = r7 + 2^(r10)
			subs		r10, r10, #1		;декремент r10
			bpl		div_loop_two		;если r10 >= 0, то переход к div_loop_two
			;---проверка	знака---
			ldr		r10, =0
			cmp		r5, #0
			submi	r7, r10, r7		;смена знака
			cmp		r6, #0
			submi	r7, r10, r7		;смена знака
			mov		pc, lr			;конец подпрограммы
			
			
			
			
			
